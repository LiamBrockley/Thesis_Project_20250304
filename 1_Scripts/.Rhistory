clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info_LUSC)[gene_info_LUSC$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(LUSC_logCPM))) return(NULL)
expr <- LUSC_logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
library(ggplot2)
library(dplyr)
# Specify multiple gene symbols
#gene_symbol <- "FOLR1"
#gene_symbol <- "KREMEN2"
gene_symbols <- c("KREMEN2", "MTHFD2")  # Add as many as you want
# Use intersect to get only common samples
matched_samples <- intersect(
colnames(logCPM),
clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info)[gene_info$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(LUSC_logCPM))) return(NULL)
expr <- logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
library(ggplot2)
library(dplyr)
# Specify multiple gene symbols
#gene_symbol <- "FOLR1"
#gene_symbol <- "KREMEN2"
gene_symbols <- c("KREMEN2", "MTHFD2")  # Add as many as you want
# Use intersect to get only common samples
matched_samples <- intersect(
colnames(logCPM),
clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info)[gene_info$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(logCPM))) return(NULL)
expr <- logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
library(ggplot2)
library(dplyr)
# Specify multiple gene symbols
#gene_symbol <- "FOLR1"
#gene_symbol <- "KREMEN2"
gene_symbols <- c("KREMEN2", "MTHFD2")  # Add as many as you want
# Use intersect to get only common samples
matched_samples <- intersect(
colnames(logCPM),
clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info)[gene_info$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(logCPM))) return(NULL)
expr <- logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
# Build label data for annotations
label_data <- LUAD_stage_I_comparison %>%
filter(rownames(.) %in% gene_symbols) %>%
mutate(Gene = rownames(.)) %>%
mutate(label = paste0("log2FC = ", round(logFC, 2),
"\np = ", signif(P.Value, 2),
"\nFDR = ", signif(adj.P.Val, 2)))
library(ggplot2)
library(dplyr)
# Specify multiple gene symbols
#gene_symbol <- "FOLR1"
#gene_symbol <- "KREMEN2"
gene_symbols <- c("KREMEN2", "MTHFD2")  # Add as many as you want
# Use intersect to get only common samples
matched_samples <- intersect(
colnames(logCPM),
clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info)[gene_info$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(logCPM))) return(NULL)
expr <- logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
# Build label data for annotations
label_data <- LUSC_stage_I_comparison %>%
filter(rownames(.) %in% gene_symbols) %>%
mutate(Gene = rownames(.)) %>%
mutate(label = paste0("log2FC = ", round(logFC, 2),
"\np = ", signif(P.Value, 2),
"\nFDR = ", signif(adj.P.Val, 2)))
# Plot
ggplot(plot_data, aes(x = Stage_grouped, y = Expression, fill = Stage_grouped)) +
geom_boxplot(outlier.shape = NA, alpha = 0.8, width = 0.5) +
geom_jitter(width = 0.2, alpha = 0.5, size = 0.8) +
geom_text(
data = label_data,
aes(label = label),
x = Inf, y = Inf, hjust = 1.1, vjust = 1.1,
inherit.aes = FALSE, size = 3.5
) +
facet_wrap(~ Gene, scales = "free_y") +
labs(title = "Expression of Selected Genes by LUSC Tumor Stage",
x = "Tumor Stage Group", y = "logCPM Expression") +
scale_fill_manual(values = c("Stage I" = "#1b9e77", "Stage II+" = "#d95f02")) +
theme_minimal(base_size = 14) +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1)
)
nrow(LUSC_stage_I_comparison_filtered_down_up)
View(LUSC_stage_I_comparison_filtered)
writeLines(rownames(LUSC_stage_I_comparison_filtered_up_up))
library(ggplot2)
library(dplyr)
# Specify multiple gene symbols
#gene_symbols <- c("KREMEN2", "MTHFD2")
gene_symbols <- c("PYCR1", "MTHFD2")
# Use intersect to get only common samples
matched_samples <- intersect(
colnames(logCPM),
clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info)[gene_info$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(logCPM))) return(NULL)
expr <- logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
# Build label data for annotations
label_data <- LUSC_stage_I_comparison %>%
filter(rownames(.) %in% gene_symbols) %>%
mutate(Gene = rownames(.)) %>%
mutate(label = paste0("log2FC = ", round(logFC, 2),
"\np = ", signif(P.Value, 2),
"\nFDR = ", signif(adj.P.Val, 2)))
# Plot
ggplot(plot_data, aes(x = Stage_grouped, y = Expression, fill = Stage_grouped)) +
geom_boxplot(outlier.shape = NA, alpha = 0.8, width = 0.5) +
geom_jitter(width = 0.2, alpha = 0.5, size = 0.8) +
geom_text(
data = label_data,
aes(label = label),
x = Inf, y = Inf, hjust = 1.1, vjust = 1.1,
inherit.aes = FALSE, size = 3.5
) +
facet_wrap(~ Gene, scales = "free_y") +
labs(title = "Expression of Selected Genes by LUSC Tumor Stage",
x = "Tumor Stage Group", y = "logCPM Expression") +
scale_fill_manual(values = c("Stage I" = "#1b9e77", "Stage II+" = "#d95f02")) +
theme_minimal(base_size = 14) +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1)
)
library(ggplot2)
library(dplyr)
# Specify multiple gene symbols
#gene_symbols <- c("KREMEN2", "MTHFD2")
#gene_symbols <- c("PYCR1", "MTHFD2")
gene_symbols <- c("WNT10B", "CTHRC1", "KREMEN2", "AGAP2‑AS1")
# Use intersect to get only common samples
matched_samples <- intersect(
colnames(logCPM),
clinical_data_filtered_early_late$bcr_patient_barcode
)
# Sanity check (optional)
length(matched_samples)  # Should be consistent with what's in both
# Create the plotting dataframe
plot_data <- do.call(rbind, lapply(gene_symbols, function(gene_symbol) {
gene_id <- rownames(gene_info)[gene_info$gene_name == gene_symbol]
if (length(gene_id) == 0 || !(gene_id %in% rownames(logCPM))) return(NULL)
expr <- logCPM[gene_id, matched_samples]
data.frame(
Gene = gene_symbol,
Expression = as.numeric(expr),
Stage_grouped = clinical_data_filtered_early_late[
match(matched_samples, clinical_data_filtered_early_late$bcr_patient_barcode),
"Stage_grouped"
],
Sample = matched_samples
)
}))
# Build label data for annotations
label_data <- LUSC_stage_I_comparison %>%
filter(rownames(.) %in% gene_symbols) %>%
mutate(Gene = rownames(.)) %>%
mutate(label = paste0("log2FC = ", round(logFC, 2),
"\np = ", signif(P.Value, 2),
"\nFDR = ", signif(adj.P.Val, 2)))
# Plot
ggplot(plot_data, aes(x = Stage_grouped, y = Expression, fill = Stage_grouped)) +
geom_boxplot(outlier.shape = NA, alpha = 0.8, width = 0.5) +
geom_jitter(width = 0.2, alpha = 0.5, size = 0.8) +
geom_text(
data = label_data,
aes(label = label),
x = Inf, y = Inf, hjust = 1.1, vjust = 1.1,
inherit.aes = FALSE, size = 3.5
) +
facet_wrap(~ Gene, scales = "free_y") +
labs(title = "Expression of Selected Genes by LUSC Tumor Stage",
x = "Tumor Stage Group", y = "logCPM Expression") +
scale_fill_manual(values = c("Stage I" = "#1b9e77", "Stage II+" = "#d95f02")) +
theme_minimal(base_size = 14) +
theme(
legend.position = "none",
plot.title = element_text(hjust = 0.5),
axis.text.x = element_text(angle = 45, hjust = 1)
)
# List of genes of interest
genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
# Get Ensembl gene IDs (assuming gene_info_LUSC has gene_name + rownames = gene_id)
gene_ids <- rownames(gene_info_LUSC)[gene_info_LUSC$gene_name %in% genes]
# List of genes of interest
genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
# Get Ensembl gene IDs (assuming gene_info has gene_name + rownames = gene_id)
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
# Subset expression matrix for just these genes
expr_subset <- logCPM[gene_ids, ]  # rows = genes, cols = samples
# Transpose so genes are columns (for correlation)
expr_subset_t <- t(expr_subset)
# Compute Spearman correlation matrix
cor_matrix <- cor(expr_subset_t, method = "spearman", use = "pairwise.complete.obs")
# Optional: round and view
round(cor_matrix, 2)
View(cor_matrix)
# List of genes of interest
genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
expr_subset <- logCPM[gene_ids, ]  # rows = genes
expr_t <- t(expr_subset)  # rows = samples, columns = genes
# Get gene names (they might not be in order in gene_ids)
gene_names <- names(gene_ids)
# Initialize matrices for rho and p-values
n <- length(gene_names)
rho_mat <- matrix(NA, n, n)
p_mat <- matrix(NA, n, n)
colnames(rho_mat) <- rownames(rho_mat) <- gene_names
colnames(p_mat) <- rownames(p_mat) <- gene_names
# Pairwise correlation tests
for (i in 1:n) {
for (j in 1:n) {
test <- cor.test(expr_t[, i], expr_t[, j], method = "spearman")
rho_mat[i, j] <- test$estimate
p_mat[i, j] <- test$p.value
}
}
# Optional: round for readability
round(rho_mat, 2)
round(p_mat, 4)
View(p_mat)
# List of genes of interest
#genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
genes <- c("WNT10B", "CTHRC1", "KREMEN2", "AGAP2‑AS1") # up-up and possibly wnt related
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
expr_subset <- logCPM[gene_ids, ]  # rows = genes
expr_t <- t(expr_subset)  # rows = samples, columns = genes
# Get gene names (they might not be in order in gene_ids)
gene_names <- names(gene_ids)
# Initialize matrices for rho and p-values
n <- length(gene_names)
rho_mat <- matrix(NA, n, n)
p_mat <- matrix(NA, n, n)
colnames(rho_mat) <- rownames(rho_mat) <- gene_names
colnames(p_mat) <- rownames(p_mat) <- gene_names
# Pairwise correlation tests
for (i in 1:n) {
for (j in 1:n) {
test <- cor.test(expr_t[, i], expr_t[, j], method = "spearman")
rho_mat[i, j] <- test$estimate
p_mat[i, j] <- test$p.value
}
}
# Optional: round for readability
round(rho_mat, 2)
round(p_mat, 4)
# List of genes of interest
#genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
genes <- c("WNT10B", "CTHRC1", "KREMEN2", "AGAP2‑AS1") # up-up and possibly wnt related
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
expr_subset <- logCPM[gene_ids, ]  # rows = genes
expr_t <- t(expr_subset)  # rows = samples, columns = genes
# Get gene names (they might not be in order in gene_ids)
gene_names <- names(gene_ids)
# Initialize matrices for rho and p-values
n <- length(gene_names)
rho_mat <- matrix(NA, n, n)
p_mat <- matrix(NA, n, n)
colnames(rho_mat) <- rownames(rho_mat) <- gene_names
colnames(p_mat) <- rownames(p_mat) <- gene_names
# Pairwise correlation tests
for (i in 1:n) {
for (j in 1:n) {
test <- cor.test(expr_t[, i], expr_t[, j], method = "spearman")
rho_mat[i, j] <- test$estimate
p_mat[i, j] <- test$p.value
}
}
# Optional: round for readability
round(rho_mat, 2)
round(p_mat, 4)
# Flatten upper triangle of p-value matrix (excluding diagonal)
upper_tri_p <- p_mat[upper.tri(p_mat)]
# Adjust p-values using Benjamini-Hochberg method
upper_tri_fdr <- p.adjust(upper_tri_p, method = "BH")
# Create an empty matrix to hold FDRs
fdr_mat <- matrix(NA, nrow = n, ncol = n)
rownames(fdr_mat) <- colnames(fdr_mat) <- gene_names
# Put FDRs back into upper triangle
fdr_mat[upper.tri(fdr_mat)] <- upper_tri_fdr
# Mirror lower triangle to make symmetric
fdr_mat[lower.tri(fdr_mat)] <- t(fdr_mat)[lower.tri(fdr_mat)]
# Optional: round and view
round(fdr_mat, 4)
# List of genes of interest
#genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
genes <- c("WNT10B", "CTHRC1", "KREMEN2", "AGAP2‑AS1") # up-up and possibly wnt related
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
expr_subset <- logCPM[gene_ids, ]  # rows = genes
expr_t <- t(expr_subset)  # rows = samples, columns = genes
# Get gene names (they might not be in order in gene_ids)
gene_names <- names(gene_ids)
# Initialize matrices for rho and p-values
n <- length(gene_names)
rho_mat <- matrix(NA, n, n)
p_mat <- matrix(NA, n, n)
colnames(rho_mat) <- rownames(rho_mat) <- gene_names
colnames(p_mat) <- rownames(p_mat) <- gene_names
# Pairwise correlation tests
for (i in 1:n) {
for (j in 1:n) {
test <- cor.test(expr_t[, i], expr_t[, j], method = "spearman")
rho_mat[i, j] <- test$estimate
p_mat[i, j] <- test$p.value
}
}
# Optional: round for readability
print("rho values")
round(rho_mat, 2)
print("p values")
round(p_mat, 4)
# Flatten upper triangle of p-value matrix (excluding diagonal)
upper_tri_p <- p_mat[upper.tri(p_mat)]
# Adjust p-values using Benjamini-Hochberg method
upper_tri_fdr <- p.adjust(upper_tri_p, method = "BH")
# Create an empty matrix to hold FDRs
fdr_mat <- matrix(NA, nrow = n, ncol = n)
rownames(fdr_mat) <- colnames(fdr_mat) <- gene_names
# Put FDRs back into upper triangle
fdr_mat[upper.tri(fdr_mat)] <- upper_tri_fdr
# Mirror lower triangle to make symmetric
fdr_mat[lower.tri(fdr_mat)] <- t(fdr_mat)[lower.tri(fdr_mat)]
# Optional: round and view
print("FDR values")
round(fdr_mat, 4)
# List of genes of interest
#genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
genes <- c("WNT10B", "CTHRC1", "KREMEN2", "AGAP2‑AS1") # up-up and possibly wnt related
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
expr_subset <- logCPM[gene_ids, ]  # rows = genes
expr_t <- t(expr_subset)  # rows = samples, columns = genes
# Get gene names (they might not be in order in gene_ids)
gene_names <- names(gene_ids)
# Initialize matrices for rho and p-values
n <- length(gene_names)
rho_mat <- matrix(NA, n, n)
p_mat <- matrix(NA, n, n)
colnames(rho_mat) <- rownames(rho_mat) <- gene_names
colnames(p_mat) <- rownames(p_mat) <- gene_names
# Pairwise correlation tests
for (i in 1:n) {
for (j in 1:n) {
test <- cor.test(expr_t[, i], expr_t[, j], method = "spearman")
rho_mat[i, j] <- test$estimate
p_mat[i, j] <- test$p.value
}
}
# Optional: round for readability
paste0("rho values\n")
round(rho_mat, 2)
paste0("p values\n")
round(p_mat, 4)
# Flatten upper triangle of p-value matrix (excluding diagonal)
upper_tri_p <- p_mat[upper.tri(p_mat)]
# Adjust p-values using Benjamini-Hochberg method
upper_tri_fdr <- p.adjust(upper_tri_p, method = "BH")
# Create an empty matrix to hold FDRs
fdr_mat <- matrix(NA, nrow = n, ncol = n)
rownames(fdr_mat) <- colnames(fdr_mat) <- gene_names
# Put FDRs back into upper triangle
fdr_mat[upper.tri(fdr_mat)] <- upper_tri_fdr
# Mirror lower triangle to make symmetric
fdr_mat[lower.tri(fdr_mat)] <- t(fdr_mat)[lower.tri(fdr_mat)]
# Optional: round and view
print("FDR values")
round(fdr_mat, 4)
# List of genes of interest
#genes <- c("PYCR1", "MTHFD2") # 'up-up' mitochondrial redox genes
genes <- c("WNT10B", "CTHRC1", "KREMEN2", "AGAP2‑AS1") # up-up and possibly wnt related
gene_ids <- rownames(gene_info)[gene_info$gene_name %in% genes]
names(gene_ids) <- gene_info$gene_name[match(gene_ids, rownames(gene_info))]
expr_subset <- logCPM[gene_ids, ]  # rows = genes
expr_t <- t(expr_subset)  # rows = samples, columns = genes
# Get gene names (they might not be in order in gene_ids)
gene_names <- names(gene_ids)
# Initialize matrices for rho and p-values
n <- length(gene_names)
rho_mat <- matrix(NA, n, n)
p_mat <- matrix(NA, n, n)
colnames(rho_mat) <- rownames(rho_mat) <- gene_names
colnames(p_mat) <- rownames(p_mat) <- gene_names
# Pairwise correlation tests
for (i in 1:n) {
for (j in 1:n) {
test <- cor.test(expr_t[, i], expr_t[, j], method = "spearman")
rho_mat[i, j] <- test$estimate
p_mat[i, j] <- test$p.value
}
}
# Optional: round for readability
paste0("rho values")
round(rho_mat, 2)
paste0("p values")
round(p_mat, 4)
# Flatten upper triangle of p-value matrix (excluding diagonal)
upper_tri_p <- p_mat[upper.tri(p_mat)]
# Adjust p-values using Benjamini-Hochberg method
upper_tri_fdr <- p.adjust(upper_tri_p, method = "BH")
# Create an empty matrix to hold FDRs
fdr_mat <- matrix(NA, nrow = n, ncol = n)
rownames(fdr_mat) <- colnames(fdr_mat) <- gene_names
# Put FDRs back into upper triangle
fdr_mat[upper.tri(fdr_mat)] <- upper_tri_fdr
# Mirror lower triangle to make symmetric
fdr_mat[lower.tri(fdr_mat)] <- t(fdr_mat)[lower.tri(fdr_mat)]
# Optional: round and view
print("FDR values")
round(fdr_mat, 4)
